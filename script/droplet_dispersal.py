r'''
Module for describing droplets dispersal in environment.
It takes as input, the wind flow generated by air_flow module and calculate droplets dispersal.
That calculus is based on the Lagrangian approach by solving Newton's equation of motion.
'''

import math
import numpy as np
import params
import const as cst
import droplet_descr
import air_flow

#air flow initialisation
v_air = air_flow.v
u_air = air_flow.u

rho_mix = params.rho_mix
rho_a = params.air_density
drop_dist = droplet_descr.drop_distrib()
alt_spray = params.alt_spray
init_velocity = droplet_descr.init_velocity()
nu_a = params.air_kviscosity
g = cst.g()

#nx = 41
#dx = 2 / (nx - 1)
nt = 3601 #1501    #nt is the number of timesteps
dt = 1  #dt is the amount of time each timestep covers (delta t)
#c = 1
'''
n_diam = len(drop_dist[:,0])
v = np.zeros((nt,n_diam))
x = np.zeros((nt,n_diam))
z = np.zeros((nt,n_diam)) # for altitude
t = np.zeros(nt)
v[0,:] = init_velocity # initialization of droplet velocity
z[0,:] = alt_spray # altitude of spray initialization
'''

#Buyoency coefficient
def C_d(diam, air_vel, drop_vel):
    Re = (diam*math.fabs(air_vel-drop_vel))/nu_a
    if Re < 0.1:
        c_d = 24/Re #stokes regime
    else :
        if Re >=0.1 and Re <= 1000 :
            c_d = (24/Re)*((1/6)*math.pow(Re, 2/3)) #transitory regime
        else :
            if Re > 1000 : c_d = 0.44 #newton regime
    return c_d

# Relaxation time
def tau(diam, air_vel, drop_vel):
    cd = C_d(diam, air_vel, drop_vel)
    tp = (4*rho_mix*diam)/(3*rho_a*cd*math.fabs(air_vel-drop_vel))
    return tp

def sed_velocity():
    r'''The sedimentation velocity of the droplet is obtained at equilibrium (dV/dt=0),
    under conditions close to the ground where the wind movement is horizontal
        *:param drop_diam: droplet diameter depend of weigth fraction
        *:return: sedimentation velocity of differents droplets
    '''


# Droplet velocity and position by diameter
x_cord = len(v_air)
y_cord = len(v_air[0])

n_diam = len(drop_dist[:,0])
v = np.zeros((nt))
x = np.zeros((n_diam, nt))
#x_tab = np.empty((0, 1), float)
z = np.zeros((n_diam, nt)) # for altitude
t_t = np.zeros(nt)
v[0] = init_velocity # initialization of droplet velocity
z[:, 0] = alt_spray # altitude of spray initialization

i = 0
j = 10
x[:, 0] = i
#Position calculation
for k in range(n_diam):
    for t in range(nt - 1):
        # vel = dt*(g*(rho_mix-rho_a)/rho_mix-(rho_a*math.pi*math.pow(drop_dist[i,0],2)*Cd*math.pow(v[n,i],2))/
        # (8*(rho_mix*math.pi*math.pow(drop_dist[i,0],3)/6))) + v[n,i]
        vel = (v[t] + g * (1 - rho_a / rho_mix) * dt) / (1 + dt / tau(drop_dist[k, 0], u_air[i, j], v[t]))
        vel_sed = math.sqrt(
            (4 * g * rho_mix * drop_dist[k, 0]) / (3 * C_d(drop_dist[k, 0], u_air[i, j], v[t]) * rho_a))
        # vel = (v[n, i] + g * (1 - rho_a / rho_mix) * dt) / (1 + dt / tau(drop_dist[i, 0], v_air[0, n], v[n, i]))
        if vel > 0: #vel >= 0
            v[t + 1] = vel  # droplet velocity
            z[k, t + 1] = alt_spray
        else :
            alt = z[k, t] - vel_sed * dt  # droplet altitude
            if alt >= 0: z[k, t + 1] = alt

        x[k, t + 1] = x[k, t] + v[t + 1] * dt  # droplet position
        #if v[t + 1] == 0 : x[k, t + 1] = 0
        #if x[k, t + 1] != x[k, t] : np.append(x_tab, np.array([x[k, t + 1]]), axis=0)
        i = round(x[k, t + 1])


'''
for k in range(n_diam):
    for i in range(x_cord-1):
        for j in range(y_cord-1):
            x[0] = i
            for t in range(nt-1):
                # vel = dt*(g*(rho_mix-rho_a)/rho_mix-(rho_a*math.pi*math.pow(drop_dist[i,0],2)*Cd*math.pow(v[n,i],2))/
                # (8*(rho_mix*math.pi*math.pow(drop_dist[i,0],3)/6))) + v[n,i]
                vel = (v[t] + g * (1 - rho_a / rho_mix) * dt) / (1 + dt / tau(drop_dist[k, 0], v_air[i, j], v[t]))
                vel_sed = math.sqrt(
                    (4 * g * rho_mix * drop_dist[k, 0]) / (3 * C_d(drop_dist[k, 0], v_air[i, j], v[t]) * rho_a))
                # vel = (v[n, i] + g * (1 - rho_a / rho_mix) * dt) / (1 + dt / tau(drop_dist[i, 0], v_air[0, n], v[n, i]))
                if vel >= 0:
                    v[t + 1] = vel  # droplet velocity
                    z[t + 1] = alt_spray
                else:
                    alt = z[t] - vel_sed * dt  # droplet altitude
                    if alt >= 0: z[t + 1] = alt

                x[t + 1] = x[t] + v[t + 1] * dt  # droplet position
'''

'''
for n in range(nt - 1):
    for i in range(n_diam):
        #vel = dt*(g*(rho_mix-rho_a)/rho_mix-(rho_a*math.pi*math.pow(drop_dist[i,0],2)*Cd*math.pow(v[n,i],2))/
                       #(8*(rho_mix*math.pi*math.pow(drop_dist[i,0],3)/6))) + v[n,i]
        vel = (v[n,i] + g * (1 - rho_a / rho_mix) * dt) / (1 + dt / tau(drop_dist[i, 0], v_air[0,0], v[n,i]))
        vel_sed = math.sqrt((4 * g * rho_mix * drop_dist[i, 0]) / (3 * C_d(drop_dist[i, 0], v_air[0,0], v[n,i]) * rho_a))
        #vel = (v[n, i] + g * (1 - rho_a / rho_mix) * dt) / (1 + dt / tau(drop_dist[i, 0], v_air[0, n], v[n, i]))
        if vel >= 0 :
            v[n+1, i] = vel # droplet velocity
            z[n+1, i] = alt_spray
        else :
            alt = z[n, i] - vel_sed*dt # droplet altitude
            if alt >= 0 : z[n+1, i] = alt

        x[n + 1, i] = x[n, i] + v[n+1, i]*dt # droplet position
'''

# Timestep
for n in range(nt):
    t_t[n] = n*dt