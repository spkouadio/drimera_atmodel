r'''
Module for describing droplets dispersal in environment.
It takes as input, the wind flow generated by air_flow module and calculate droplets dispersal.
That calculus is based on the Lagrangian approach by solving Newton's equation of motion.

Module for calculate droplets concentration in environment.
It takes as input, the droplet caracteristics generated by droplet_dispersal module and simulates the dispersion
of droplets in air using the Euler-Lagrange approach and the Finite Difference Method.
Pesticides concentration is then determinated.
'''

import math
import numpy as np
from script.const import constants
#from params import *
#import const as cst
#import droplet_descr
#import air_flow

class droplet_dispersal(object):
    # nx = 41
    # dx = 2 / (nx - 1)
    #nt = 3601  # 1501    #nt is the number of timesteps
    dt = 1  # dt is the amount of time each timestep covers (delta t)
    # c = 1

    def __init__(self, timestep, v_air, u_air, rho_mix, rho_a, alt_spray, nu_a, drop_dist, init_velocity, x0, y0, z_pos):
        self.nt = timestep+1
        self.v_air = v_air
        self.u_air = u_air
        self.rho_mix = rho_mix
        self.rho_a = rho_a
        self.alt_spray = alt_spray
        self.nu_a = nu_a
        self.drop_dist = drop_dist
        self.init_velocity = init_velocity

        # air flow initialisation
        # v_air = air_flow.v
        # u_air = air_flow.u
        # rho_mix = 0 # params.rho_mix
        # rho_a = 0 #params.air_density
        # alt_spray = 0 #params.alt_spray
        # nu_a = 0 #params.air_kviscosity
        # drop_dist = droplet_descr.drop_distrib()
        # init_velocity = droplet_descr.init_velocity()
        #
        self.g = constants().g()

        # Droplet velocity and position by diameter
        x_cord = len(self.v_air)
        y_cord = len(self.v_air[0])

        self.n_diam = len(self.drop_dist[:, 0])
        self.v = np.zeros((self.nt))
        self.x = np.zeros((self.n_diam, self.nt))
        #self.x = np.zeros((1+z_pos*10, n_diam, self.nt))
        # x_tab = np.empty((0, 1), float)
        self.z = np.zeros((self.n_diam, self.nt+1))  # for altitude
        self.t_t = np.zeros(self.nt)
        self.v[0] = self.init_velocity  # initialization of droplet velocity
        self.z[:, 0] = self.alt_spray  # altitude of spray initialization

        self.i = x0
        self.j = y0
        self.x[:, 0] = self.i
        self.z_position = z_pos

    # Buyoency coefficient
    def C_d(self, diam, air_vel, drop_vel):
        Re = (diam * math.pow(10, -6) * math.fabs(air_vel - drop_vel)) / self.nu_a
        if Re < 0.1:
            c_d = 24 / Re  # stokes regime
        else:
            if Re >= 0.1 and Re <= 1000:
                c_d = (24 / Re) * ((1 / 6) * math.pow(Re, 2 / 3))  # transitory regime
            else:
                if Re > 1000: c_d = 0.44  # newton regime
        return c_d

    # Relaxation time
    def tau(self, diam, air_vel, drop_vel):
        cd = self.C_d(diam, air_vel, drop_vel)
        tp = (4 * self.rho_mix * diam * math.pow(10, -6)) / (3 * self.rho_a * cd * math.fabs(air_vel - drop_vel))
        return tp

    def sed_velocity(self):
        r'''The sedimentation velocity of the droplet is obtained at equilibrium (dV/dt=0),
        under conditions close to the ground where the wind movement is horizontal
            *:param drop_diam: droplet diameter depend of weigth fraction
            *:return: sedimentation velocity of differents droplets
        '''


        # Position calculation
        for k in range(self.n_diam):
            for t in range(self.nt-1):
                # vel = dt*(g*(rho_mix-rho_a)/rho_mix-(rho_a*math.pi*math.pow(drop_dist[i,0],2)*Cd*math.pow(v[n,i],2))/
                # (8*(rho_mix*math.pi*math.pow(drop_dist[i,0],3)/6))) + v[n,i]
                vel = (self.v[t] + self.g * (1 - self.rho_a / self.rho_mix) * self.dt) / (1 + self.dt / self.tau(self.drop_dist[k, 0], self.u_air[self.i, self.j], self.v[t]))
                vel_sed = math.sqrt(
                    (4 * self.g * (self.rho_mix - self.rho_a) * self.drop_dist[k, 0] * math.pow(10, -6)) / (3 * self.C_d(self.drop_dist[k, 0], self.u_air[self.i, self.j], self.v[t]) * self.rho_a))
                # vel = (v[n, i] + g * (1 - rho_a / rho_mix) * dt) / (1 + dt / tau(drop_dist[i, 0], v_air[0, n], v[n, i]))
                if vel > 0:  # vel >= 0
                    self.v[t + 1] = vel  # droplet velocity
                    self.z[k, t + 1] = self.alt_spray
                else:
                    alt = self.z[k, t] - vel_sed * self.dt  # droplet altitude
                    if alt >= 0: self.z[k, t + 1] = alt

                self.x[k, t + 1] = self.x[k, t] + self.v[t + 1] * self.dt  # droplet position
                # if v[t + 1] == 0 : x[k, t + 1] = 0
                # if x[k, t + 1] != x[k, t] : np.append(x_tab, np.array([x[k, t + 1]]), axis=0)
                #self.i = round(self.x[k, t + 1])
        #return (x, z)
        #print(self.x)

        # Timestep
        for n in range(self.nt):
            self.t_t[n] = n * self.dt


    # Define parameters
    nx = 101  # number of grid points
    ny = 101
    # nt = 100 #params.time_nt  # number of time steps
    dx = 0.1  # grid spacing
    dy = 0.1
    dt = 0.01  # time step
    D = 0.1  # diffusion coefficient


    # Define finite difference operator
    def laplacian(self, c):
        lap = np.zeros_like(c)
        lap[1:-1, 1:-1] = (c[2:, 1:-1] - 2 * c[1:-1, 1:-1] + c[:-2, 1:-1]) / self.dx ** 2 \
                          + (c[1:-1, 2:] - 2 * c[1:-1, 1:-1] + c[1:-1, :-2]) / self.dy ** 2
        return lap

    def conc_cal(self, u_air, alpha_buoy, c_0, i, j, k):
        r'''
        Concentration advection-diffusion calculus module. The sedimentation velocity of the droplet is obtained
        at equilibrium (dV/dt=0), under conditions close to the ground where the wind movement is horizontal
        :param u_air: air velocity
        :param alpha_buoy: Buyoency coefficient
        :param c_0: initial concentration at the point of dispersion
        :param i: x-coordinate of the dispersion point
        :param j: y-coordinate of the dispersion point
        :param k: position of droplet in diameter range
        :return: concentration
        '''
        u = u_air
        alpha = alpha_buoy
        c = np.zeros((self.nx, self.ny))  # concentration of particles
        c[i+1, j] = c_0  # Set initial condition
        self.u_p = np.zeros((self.nx, self.ny))  # particle velocity in x-direction
        self.v_p = np.zeros((self.nx, self.ny))  # particle velocity in y-direction

        # Time loop
        for n in range(self.nt):
            # Update particle velocity based on fluid velocity
            self.u_p = alpha * u + (1 - alpha) * self.u_p
            self.v_p = alpha * 0 + (1 - alpha) * self.v_p

            vel_sed = math.sqrt((4 * self.g * (self.rho_mix-self.rho_a) * self.drop_dist[k, 0] * math.pow(10, -6)) /
                                (3 * self.C_d(self.drop_dist[k, 0], self.u_air[self.i, self.j], self.v[n]) * self.rho_a))

            # Droplet altitude determination
            if vel_sed > self.u_p[self.i, self.j] :
                alt = self.z[k, n] - vel_sed * self.dt  # droplet altitude
                if alt >= 0: self.z[k, n + 1] = alt
                #c += 0
            else:
                self.z[k, n + 1] = self.alt_spray

            # Dispersion calculation by advection-diffusion equation at non-zero altitude
            if self.z[k, n + 1] != 0 :
                # Calculate particle diffusion
                c += self.dt * self.D * self.laplacian(c)

                # Calculate advection of particles
                c[1:-1, 1:-1] -= self.dt * self.u_p[1:-1, 1:-1] * (c[2:, 1:-1] - c[:-2, 1:-1]) / (2 * self.dx) \
                                 + self.dt * self.v_p[1:-1, 1:-1] * (c[1:-1, 2:] - c[1:-1, :-2]) / (2 * self.dy)

            # Enforce boundary conditions
            c[:, 0] = 0
            c[:, -1] = 0
            c[0, :] = 0
            c[-1, :] = 0

        c[c < 0] = 0

        return c.transpose()