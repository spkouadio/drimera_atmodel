r'''
Module for calculate droplets concentration in environment.
It takes as input, the droplet caracteristics generated by droplet_dispersal module and simulates the dispersion
of droplets in air using the Euler-Lagrange approach and the Finite Difference Method.
Pesticides concentration is then determinated.
'''


import numpy as np
import matplotlib.pyplot as plt

# Define parameters
nx = 101  # number of grid points
ny = 101
nt = 100  # number of time steps
dx = 0.1  # grid spacing
dy = 0.1
dt = 0.01  # time step
#u = 1  # fluid velocity
D = 0.1  # diffusion coefficient
#alpha = 0.5  # weighting factor for particle velocity

# Initialize arrays
#c = np.zeros((nx, ny))  # concentration of particles
#u_p = np.zeros((nx, ny))  # particle velocity in x-direction
#v_p = np.zeros((nx, ny))  # particle velocity in y-direction

# Set initial condition
#c[50, 50] = 1


# Define finite difference operator
def laplacian(c):
    lap = np.zeros_like(c)
    lap[1:-1, 1:-1] = (c[2:, 1:-1] - 2 * c[1:-1, 1:-1] + c[:-2, 1:-1]) / dx ** 2 \
                      + (c[1:-1, 2:] - 2 * c[1:-1, 1:-1] + c[1:-1, :-2]) / dy ** 2
    return lap




def conc_cal(u_air, alpha_buoy, c_0, i, j):
    r'''
    Concentration advection-diffusion calculus module
    :param u_air: air velocity
    :param alpha_buoy: Buyoency coefficient
    :param c_0: initial concentration at the point of dispersion
    :return: concentration
    '''
    u = u_air
    alpha = alpha_buoy
    c = np.zeros((nx, ny))   # concentration of particles
    c[j, i] = c_0 # Set initial condition
    u_p = np.zeros((nx, ny))  # particle velocity in x-direction
    v_p = np.zeros((nx, ny))  # particle velocity in y-direction

    # Time loop
    for n in range(nt):
        # Update particle velocity based on fluid velocity
        u_p = alpha * u + (1 - alpha) * u_p
        v_p = alpha * 0 + (1 - alpha) * v_p

        # Calculate particle diffusion
        c += dt * D * laplacian(c)

        # Calculate advection of particles
        c[1:-1, 1:-1] -= dt * u_p[1:-1, 1:-1] * (c[2:, 1:-1] - c[:-2, 1:-1]) / (2 * dx) \
                         + dt * v_p[1:-1, 1:-1] * (c[1:-1, 2:] - c[1:-1, :-2]) / (2 * dy)

        # Enforce boundary conditions
        c[:, 0] = 0
        c[:, -1] = 0
        c[0, :] = 0
        c[-1, :] = 0
    return c

    # Plot concentration profile
"""
    if n % 10 == 0:
        plt.imshow(c, cmap='hot', origin='lower', extent=[0, 10, 0, 10])
        plt.colorbar()
        plt.xlabel('x')
        plt.ylabel('y')
        plt.title(f'Time = {n * dt:.2f}')
        plt.show()
"""

import numpy as np
import matplotlib.pyplot as plt

# Define parameters
nx = 101  # number of grid points
ny = 101
nt = 100  # number of time steps
dx = 0.1  # grid spacing
dy = 0.1
gamma = 1.4  # specific heat ratio
CFL = 0.1  # CFL number
p_inf = 101325  # free stream pressure
rho_inf = 1.225  # free stream density
u_inf = 100  # free stream velocity

# Initialize arrays
u = np.zeros((nx, ny))  # x-velocity
v = np.zeros((nx, ny))  # y-velocity
p = np.ones((nx, ny)) * p_inf  # pressure
rho = np.ones((nx, ny)) * rho_inf  # density

# Set initial condition
u[:, :] = u_inf
p[:, :] = p_inf
rho[:, :] = rho_inf


# Define finite difference operator
def ddt(f, u, v):
    dfdt = np.zeros_like(f)
    dfdx = np.zeros_like(f)
    dfdy = np.zeros_like(f)

    dfdx[1:-1, 1:-1] = (f[2:, 1:-1] - f[:-2, 1:-1]) / (2 * dx)
    dfdy[1:-1, 1:-1] = (f[1:-1, 2:] - f[1:-1, :-2]) / (2 * dy)

    dfdt[1:-1, 1:-1] = - u[1:-1, 1:-1] * dfdx[1:-1, 1:-1] \
                       - v[1:-1, 1:-1] * dfdy[1:-1, 1:-1]

    return dfdt


# Time loop
for n in range(nt):
    # Calculate time step
    dt = CFL * min(dx / np.max(np.abs(u)), dy / np.max(np.abs(v)))

    # Calculate pressure from density and velocity
    p = (gamma - 1) * (rho * (u ** 2 + v ** 2) / 2 - p_inf)

    # Calculate density from pressure and velocity
    rho = p / ((gamma - 1) * (u ** 2 + v ** 2) / 2 + p_inf)

    # Calculate x-velocity
    u -= dt * ddt(rho * u, u, v) / rho

    # Calculate y-velocity
    v -= dt * ddt(rho * v, u, v) / rho

    # Apply boundary conditions
    u[0, :] = u_inf
    u[-1, :] = u_inf
    u[:, 0] = 0
    u[:, -1] = 0
    v[0, :] = 0
    v[-1, :] = 0
    v[:, 0] = 0
    v[:, -1] = 0
    p[0, :] = p_inf
    p[-1, :] = p_inf
    p[:, 0] = p_inf
    p[:, -1] = p_inf

    # Plot velocity profile
    if n % 10 == 0:
        speed = np.sqrt(u ** 2 + v ** 2)
        plt.imshow(speed, cmap='cool', origin='lower', extent=[0, 10, 0, 10])
        plt.colorbar()
        plt.xlabel
