r'''
Module for calculate droplets concentration in environment.
It takes as input, the droplet caracteristics generated by droplet_dispersal module and simulates the dispersion
of droplets in air using the Euler-Lagrange approach and the Finite Difference Method.
Pesticides concentration is then determinated.
'''


import numpy as np

class concent_calc(object):

    # Define parameters
    nx = 301  # number of grid points
    ny = 301
    # nt = 100 #params.time_nt  # number of time steps
    dx = 0.1  # grid spacing
    dy = 0.1
    dt = 0.01  # time step
    D = 0.1  # diffusion coefficient

    def __init__(self, nt):
        self.nt = nt

    # Define finite difference operator
    def laplacian(self, c):
        lap = np.zeros_like(c)
        lap[1:-1, 1:-1] = (c[2:, 1:-1] - 2 * c[1:-1, 1:-1] + c[:-2, 1:-1]) / self.dx ** 2 \
                          + (c[1:-1, 2:] - 2 * c[1:-1, 1:-1] + c[1:-1, :-2]) / self.dy ** 2
        return lap

    def conc_cal(self, u_air, alpha_buoy, c_0, i, j):
        r'''
        Concentration advection-diffusion calculus module
        :param u_air: air velocity
        :param alpha_buoy: Buyoency coefficient
        :param c_0: initial concentration at the point of dispersion
        :return: concentration
        '''
        u = u_air
        alpha = alpha_buoy
        c = np.zeros((self.nx, self.ny))  # concentration of particles
        c[i, j] = c_0  # Set initial condition
        self.u_p = np.zeros((self.nx, self.ny))  # particle velocity in x-direction
        self.v_p = np.zeros((self.nx, self.ny))  # particle velocity in y-direction

        # Time loop
        for n in range(self.nt):
            # Update particle velocity based on fluid velocity
            self.u_p = alpha * u + (1 - alpha) * self.u_p
            self.v_p = alpha * 0 + (1 - alpha) * self.v_p

            # Calculate particle diffusion
            c += self.dt * self.D * self.laplacian(c)

            # Calculate advection of particles
            c[1:-1, 1:-1] -= self.dt * self.u_p[1:-1, 1:-1] * (c[2:, 1:-1] - c[:-2, 1:-1]) / (2 * self.dx) \
                             + self.dt * self.v_p[1:-1, 1:-1] * (c[1:-1, 2:] - c[1:-1, :-2]) / (2 * self.dy)

            # Enforce boundary conditions
            c[:, 0] = 0
            c[:, -1] = 0
            c[0, :] = 0
            c[-1, :] = 0

        c[c < 0] = 0

        return c.transpose()